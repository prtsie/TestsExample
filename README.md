На этом репозитории можно потренироваться в написании юнит-тестов. Юнит-тесты здесь можно написать на репозитории (паттерн такой для доступа к БД, https://habr.com/ru/articles/248505/) и на сервисы с бизнес-логикой. В коде уже есть примеры тестов для репозиториев и сервисов.

Проект я решил структурировать по принципам "чистой архитектуры" (https://habr.com/ru/articles/784922/, https://www.youtube.com/playlist?list=PLzYkqgWkHPKBcDIP5gzLfASkQyTdy0t4k), потому что она мне нравится, а ещё потому, что, кроме неё, я знаю только архитектуру "как попало".

В чистой архитектуре есть четыре слоя. Слой "presentation" ближе всего к пользователю и обрабатывает его запросы. Для обработки запроса он обращается к слою "application", в котором лежат сервисы, манипулирующие моделями. Слой application использует модели, например, сущностей из БД, как в этом репозитории и происходит. Модели хранятся в своём слое "domain". Слой application ещё может использовать какие-то сервисы, которые к бизнес-логике не относятся, но необходимы для её выполнения. Такие сервисы помещаются в слое инфраструктуры. Вот как это выглядит на картинке, где зависимости изображены стрелочками:
![image](https://github.com/user-attachments/assets/3c14ee92-da04-401b-9303-1f50f1350a5a)
Хоть слой application не зависит от слоя инфраструктуры, но всё равно использует сервисы оттуда. Такая возможность достигается тем, что этот слой определяет интерфейсы сервисов, необходимых ему для работы, инфраструктурный слой реализует эти интерфейсы, а самый верхний слой presentation, который транзитивно имеет зависимости от всех остальных слоёв, просто использует логику слоя application, предоставляя ему реализацию инфраструктурных сервисов из слоя infrastructure. Достигается это с помощью паттерна dependency injection (https://habr.com/ru/articles/350068/).

Точкой входа в приложение как и всегда является метод Main в классе Program. В нём идёт настройка приложения и запуск обработки запросов. ASP.NET Core предоставляет класс WebApplicationBuilder для настройки таких вещей как DI-контейнер (https://habr.com/ru/articles/350068/) в приложении. В этом приложении настройка вынесена в метод расширения (https://metanit.com/sharp/tutorial/3.18.php), в котором вызываются другие методы расширения из разных слоёв (у каждого слоя есть свой метод расширения для регистрации зависимостей, относящихся к этому слою, в DI-контейнере. Вызвав у билдера метод Build мы получаем само приложение, у которого ещё нужно настроить request piprline — конвейер обработки запросов (https://metanit.com/sharp/aspnet6/2.2.php). Для этого я тоже написал метод расширения, в котором постарался комментариями всё подробно объяснить. После вызова метода Run у WebApplication приложение начнёт обрабатывать запросы, что можно проверить, введя в браузер адрес, который можно получить в окне консоли, куда приложение выводит логи. Вообще, браузер должен открыться и сам, если запустить приложение через IDE.

Работа с БД целиком построена на классе DbContext из библиотеки Entity Framework Core. Реализация контекста находится в слое инфраструктуры. Внутри неё в переопределённом методе вызывается метод, который ищет по всей сборке особые классы, которые наследуют интерфейс IEntityTypeConfiguration, эти классы дают понять EF Core структуру БД, с которой он должен работать. Вызов метода Database.EnsureCreated() в конструкторе создаст БД с указанной структурой, если EF Core не найдёт существующей (это плохое решение и надо делать это с помощью миграций, но так гораздо проще, так что пусть). EF Core для подключения к БД требует строку подключения, в которой должно быть указано, где она находится, как называется и какие данные нужны для авторизации. Вы можете просто использовать строку подключения к БД MS SQL Server (если я не забыл задать её, она и так уже должна использоваться), и всё должно само заработать, если у вас установлен SQL Server (можно будет даже увидеть базу в Management studio). Но класс контекста не должен использоваться нигде, кроме слоя инфраструктуры, вместо него используются репозитории, в которых уже используется контекст как зависимость (и то не напрямую, а через интерфейсы).
